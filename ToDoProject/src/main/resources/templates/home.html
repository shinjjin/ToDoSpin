<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>ToDo & Gl√ºcksrad</title>
    <link rel="stylesheet" th:href="@{/style.css}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
</head>
<body>
<header class="site-header" aria-hidden="true">
    <img th:src="@{/icons/coins.svg}" alt="Coins" class="header-icon" title="Coins">
</header>

<div class="page-wrapper">
    <h1 class="page-title">WHEEL OF TASKS</h1>
    <div class="left-column">
        <div class="task-container">
            <!-- Gew√§hlte Aufgabe: erscheint nur wenn task.chosen und nicht erledigt -->
            <div th:each="task : ${tasks}" th:if="${task.chosen and !task.done}" class="chosen-task">
                <strong>üéØ Aktuelle Aufgabe:</strong>
                <p th:text="${task.name}" style="font-size: 1.2rem; color:#390703; margin: 10px 0;"></p>
                <!-- Formular zum Markieren als erledigt-->
               <form th:action="@{/taskDone}" method="post">
                   <input type="hidden" name="id" th:value="${task.id}">
                   <button type="button" onclick="completeTaskConfetti(this)" class="btn-primary">
                       Als erledigt markieren !
                   </button>
               </form>
           </div>
           <div class="controls">
               <!-- Eingabefeld zum Hinzuf√ºgen neuer Tasks -->
               <form id="addForm" th:action="@{/add}" method="post" class="add-form">
                   <input type="text" name="text" placeholder="Neue Task..." required maxlength="28"
                          th:disabled="${openTasks.size() >= 15}" class="add-input">
               </form>
               <div class="button-group">
                   <!-- Button zum Abschicken des addForm -->
                   <button type="submit" form="addForm" th:disabled="${openTasks.size() >= 15}" class="btn-primary">
                       Hinzuf√ºgen
                   </button>
                   <!-- Formular zum L√∂schen aller Tasks -->
                   <form th:action="@{/deleteAll}" method="post" class="delete-all-form">
                       <button type="submit" class="btn-danger">
                           Alle Tasks l√∂schen
                       </button>
                   </form>
               </div>
           </div>
            <!-- Hinweis, wenn maximale Anzahl erreicht ist -->
           <div th:if="${openTasks.size() >= 15}" style="color:#E9E4E4; margin-top: 8px;">
               Maximale Anzahl erreicht
           </div>
            <!-- Liste der offenen Tasks -->
           <div class="task-list">
               <div th:each="task : ${openTasks}" class="task">
                   <!-- F√ºr jeden openTask ein Formular zum Editieren und ein Formular zum L√∂schen -->
                   <form th:action="@{/edit}" method="post" class="edit-form">
                       <input type="hidden" name="id" th:value="${task.id}">
                       <input type="text" name="text" th:value="${task.name}" maxlength="28" class="edit-input">
                       <button type="submit" class="icon-button edit">
                           <img th:src="@{/icons/Edit.svg}" alt="Bearbeiten" class="icon-img">
                       </button>
                   </form>
                   <form th:action="@{/delete}" method="post" class="delete-form">
                       <input type="hidden" name="id" th:value="${task.id}">
                       <button type="submit" class="icon-button edit">
                           <img th:src="@{/icons/Bin.svg}" alt="L√∂schen" class="icon-img">
                       </button>
                   </form>
               </div>
           </div>
       </div>
        <!-- Bereich f√ºr erledigte Aufgaben -->
       <div class="done-container">
           <h3>Erledigte Aufgaben</h3>
           <div class="done-scroll">
               <div th:each="task : ${tasks}" th:if="${task.done}" class="task done-item" style="opacity: 0.6; text-decoration: line-through;">
                   <span th:text="${task.name}"></span>
               </div>
           </div>
       </div>
   </div>
   <div class="wheel-column">
       <!-- Pointer-Grafik √ºber dem Canvas -->
       <img th:src="@{/icons/Pointer.png}" alt="Pointer" id="pointer" class="pointer-img">
       <div class="wheel-frame">
           <!-- Wheel-Background-Image -->
           <img th:src="@{/icons/Wheel2.png}" alt="" class="wheel-bg">
           <canvas id="canvas" width="400" height="400"></canvas>
       </div>
       <span id="spinWrapper" class="spin-wrapper" title="JETZT DREHEN">
           <button id="spinBtn" class="spin-btn" onclick="startSpin()" aria-label="Jetzt drehen">
               <img th:src="@{/icons/Spin2.png}" alt="Drehen" class="spin-icon">
           </button>
       </span>
   </div>
</div>

<script>
    //Script f√ºr die Konfetti-Animation beim Erledigen einer Aufgabe
   function completeTaskConfetti(button) {
       const form = button.closest("form");
       button.classList.add("goldenglow");

       // Position f√ºr den Konfetti-Urprung berechnen
       const rect = button.getBoundingClientRect();
       const x = (rect.left + rect.width / 2) / window.innerWidth;
       const y = (rect.top + rect.height / 2) / window.innerHeight;
       confetti({
           particleCount: 25,
           spread: 180,
           startVelocity: 20,
           gravity: 0.9,
           ticks: 80,
           origin: { x, y },
           colors: ['#fbbf0d', '#ff9800', '#ffffff']
       });
       // Verz√∂gerung, damit Animation sichtbar ist, dann Formular absenden
       setTimeout(() => {
           form.submit();
       }, 1750);
   }
</script>

<script th:inline="javascript">
    //Script f√ºr das Gl√ºcksrad, l√§dt die Daten, zeichnet das Rad und steuert die Animation
   let tasksForWheel = [];
   let chosenTask = [];
   const canvas = document.getElementById("canvas");
   const ctx = canvas.getContext("2d");
   const WHEEL_STROKE_COLOR = '#FDEED5';
   const WHEEL_LINE_WIDTH = 2;
   let currentAngle = 0;
   let isSpinning = false;

   //Initiale Daten vom Backend laden, um das Rad zu zeichnen und den Button-Status zu setzen
   async function loadWheelData() {
       const responseOpenTasks = await fetch('/api/tasks/open');
       tasksForWheel = await responseOpenTasks.json();
       drawWheel();

       const responseChosenTasks = await fetch('/api/tasks/chosen');
       chosenTask = await responseChosenTasks.json();

       // Button- und Wrapper-Referenzen
       const spinBtn = document.getElementById("spinBtn");
       const spinWrapper = document.getElementById("spinWrapper");

       if (tasksForWheel.length < 1) {
           spinBtn.disabled = true;
           spinBtn.style.opacity = "0.5";
           spinBtn.setAttribute('aria-label', "F√ºge eine Aufgabe hinzu");
           spinBtn.title = "F√ºge eine Aufgabe hinzu";
           spinWrapper.title = "F√ºge eine Aufgabe hinzu"; // Tooltip am Wrapper setzen
       } else if (chosenTask.length > 0) {
           spinBtn.disabled = true;
           spinBtn.style.opacity = "0.5";
           spinBtn.setAttribute('aria-label', "Erledige erst deine Aufgabe");
           spinBtn.title = "Erledige erst deine Aufgabe";
           spinWrapper.title = "Erledige erst deine Aufgabe"; // Tooltip am Wrapper setzen
       } else {
           spinBtn.disabled = false;
           spinBtn.style.opacity = "1";
           spinBtn.setAttribute('aria-label', "JETZT DREHEN");
           spinBtn.title = "JETZT DREHEN";
           spinWrapper.title = "JETZT DREHEN"; // Tooltip am Wrapper setzen
       }
   }

    // Zeichnet das Wheel basierend auf tasksForWheel und currentAngle
   function drawWheel() {
       if (tasksForWheel.length === 0) {
           ctx.clearRect(0,0,400,400);
           ctx.font = "16px Arial";
           return;
       }
       const arc = (2 * Math.PI) / tasksForWheel.length;
       const colors = ['#A31000', "#E9E4E4"];

       ctx.lineWidth = WHEEL_LINE_WIDTH;
       ctx.strokeStyle = WHEEL_STROKE_COLOR;

       ctx.clearRect(0,0, 400, 400);
       tasksForWheel.forEach((task, i) => {
           const angle = currentAngle + i * arc;
           ctx.beginPath();
           ctx.fillStyle = colors[i % colors.length];
           ctx.moveTo(200, 200);
           ctx.arc(200, 200, 190, angle, angle + arc);
           ctx.fill();
           ctx.stroke();

           // Text-Beschriftung des Segments (gek√ºrzt auf 12 Zeichen)
           ctx.save();
           ctx.translate(200, 200);
           ctx.rotate(angle + arc / 2);
           ctx.fillStyle = "#390703";
           ctx.font = "14px Arial";
           ctx.fillText(task.name.substring(0, 12), 70, 5);
           ctx.restore();
       });
   }
    // Startet die Spin-Animation
   function startSpin() {
       const spinBtn = document.getElementById("spinBtn");
       const spinWrapper = document.getElementById("spinWrapper");

       if (isSpinning || spinBtn.disabled) return;

       isSpinning = true;
       spinBtn.disabled = true;
       spinBtn.style.opacity = "0.5";
       spinWrapper.style.pointerEvents = "none";

       let velocity = Math.random() * 0.3 + 0.4;
       const animate = () => {
           velocity *= 0.985;
           currentAngle += velocity;
           drawWheel();
           if (velocity > 0.002) requestAnimationFrame(animate);
           else finishSpin();
       };
       animate();
   }

    // Ende der Spin-Animation: Gewinner berechnen, Konfetti, anschlie√üend serverseitige Auswahl aufrufen
   function finishSpin() {
       const arc = (2 * Math.PI) / tasksForWheel.length;

       // Berechnung des Index, der am Pointer landet
       const index = Math.floor(((2 * Math.PI - (currentAngle % (2 * Math.PI)) + 1.5 * Math.PI) % (2 * Math.PI)) / arc);
       const winner = tasksForWheel[index];

       const duration = 3 * 1000;
       const end = Date.now() + duration;

       (function frame() {
           confetti({ particleCount: 3, angle: 60, spread: 55, origin: { x: 0 }, colors: ['#ff0000', '#00ff00', '#0000ff', '#ffff00'] });
           confetti({ particleCount: 3, angle: 120, spread: 55, origin: { x: 1 }, colors: ['#ff0000', '#00ff00', '#0000ff', '#ffff00'] });
           if (Date.now() < end) requestAnimationFrame(frame);
       }());

        // Nach kurzer Verz√∂gerung: Aufruf des Controllers, der die Aufgabe als "chosen" markiert
       setTimeout(() => {
           window.location.href = "/chooseFromWheel/" + winner.id;
       }, 2000);
   }

   loadWheelData();
</script>
</body>
</html>