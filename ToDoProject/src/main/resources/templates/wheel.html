<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Glücksrad</title>
    <style>
        body { font-family: sans-serif; text-align: center; background-color: #f4f4f4; padding: 20px;}
        h2 { color: #333; }

        #wheel-container {
            position: relative;
            width: 500px;
            height: 500px;
            margin: 0 auto;
        }

        #canvas { width: 100%; height: 100%; }

        /* Der Zeiger (Dreieck) oben */
        #pointer {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 20px solid transparent;
            border-right: 20px solid transparent;
            border-top: 30px solid #333;
            z-index: 10;
        }

        #spinBtn {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 1.5rem;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 4px #1e7e34;
        }
        #spinBtn:active { box-shadow: 0 2px #1e7e34; transform: translateY(2px); }
        #spinBtn:disabled { background-color: #ccc; cursor: not-allowed; box-shadow: none; }

        .back-link { display: block; margin-top: 20px; color: #666; text-decoration: none;}
    </style>
</head>
<body>

<h2>Entscheidungshilfe</h2>

<div th:if="${openTasks.empty}">
    <p>Keine offenen Aufgaben vorhanden!</p>
    <a href="/" class="back-link">Zurück zur Liste</a>
</div>

<div th:unless="${openTasks.empty}">
    <div id="wheel-container">
        <div id="pointer"></div>
        <canvas id="canvas" width="500" height="500"></canvas>
    </div>

    <button id="spinBtn" onclick="spin()">DREHEN!</button>
    <a href="/" class="back-link">Abbrechen</a>
</div>

<script th:inline="javascript">
    /* Hier holen wir die Daten aus Java (Thymeleaf) und bauen ein JS-Array.
       Das ist der wichtigste Teil der Verbindung!
    */
    const tasks = [];

    /*[# th:each="task : ${openTasks}"]*/
    tasks.push({
        id: /*[[${task.id}]]*/ 0,
        name: /*[[${task.name}]]*/ "Task Name"
    });
    /*[/]*/

    // --- Canvas Zeichenlogik ---
    const canvas = document.getElementById("canvas");
    if (canvas) {
        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const center = width / 2;
        const radius = width / 2 - 10; // etwas Rand lassen

        let currentAngle = 0; // Aktueller Drehwinkel
        const arc = (2 * Math.PI) / tasks.length; // Größe eines Tortenstücks

        // Farben für die Segmente
        const colors = ["#FF5733", "#33FF57", "#3357FF", "#F333FF", "#FF33A8", "#33FFF5", "#FFC300"];

        function drawWheel() {
            ctx.clearRect(0,0, width, width);

            for(let i = 0; i < tasks.length; i++) {
                const angle = currentAngle + i * arc;

                ctx.beginPath();
                ctx.fillStyle = colors[i % colors.length];
                ctx.moveTo(center, center);
                ctx.arc(center, center, radius, angle, angle + arc);
                ctx.lineTo(center, center);
                ctx.fill();
                ctx.stroke(); // Schwarze Linien zwischen Segmenten

                // Text zeichnen
                ctx.save();
                ctx.translate(center, center);
                ctx.rotate(angle + arc / 2);
                ctx.textAlign = "right";
                ctx.fillStyle = "white";
                ctx.font = "bold 20px Arial";
                ctx.fillText(tasks[i].name, radius - 20, 10);
                ctx.restore();
            }
        }

        drawWheel(); // Einmalig zeichnen beim Laden

        // --- Dreh-Logik ---
        let isSpinning = false;

        function spin() {
            if(isSpinning) return;
            isSpinning = true;
            document.getElementById("spinBtn").disabled = true;

            // Zufällige Drehgeschwindigkeit und Dauer
            let velocity = Math.random() * 0.5 + 0.5; // Startgeschwindigkeit
            let friction = 0.985; // Bremswirkung (kleiner = schnellerer Stopp)

            function animate() {
                velocity *= friction; // Langsamer werden
                currentAngle += velocity;

                // Winkel normalisieren (damit er nicht unendlich groß wird)
                if(currentAngle >= 2 * Math.PI) currentAngle -= 2 * Math.PI;

                drawWheel();

                if(velocity > 0.002) {
                    requestAnimationFrame(animate);
                } else {
                    // GESTOPPT! Gewinner berechnen.
                    finishSpin();
                }
            }
            animate();
        }

        function finishSpin() {
            // Da Canvas bei 0 rad rechts anfängt (3 Uhr) und wir im Uhrzeigersinn drehen,
            // müssen wir etwas rechnen, um zu wissen, welches Segment bei 12 Uhr (270 Grad / 3 PI/2) steht.

            // Wir normalisieren den Winkel so, dass 0 oben ist für die Berechnung
            const degree = (currentAngle * 180 / Math.PI) % 360;

            // Welches Segment berührt den Zeiger (oben)?
            // Die Logik ist etwas invertiert, da sich das Rad dreht, nicht der Zeiger.
            // Ein Segment Index i deckt den Bereich [i*arc, (i+1)*arc] ab.
            // Wir berechnen den Winkel, der gerade "oben" (bei 3/2 PI) ist.

            const index = Math.floor(((2 * Math.PI - currentAngle + 1.5 * Math.PI) % (2 * Math.PI)) / arc);

            const winningTask = tasks[index];

            alert("Gewonnen: " + winningTask.name);

            // WICHTIG: Zurück zum Server leiten und ID übergeben
            window.location.href = "/chooseFromWheel/" + winningTask.id;
        }
    }
</script>
</body>
</html>